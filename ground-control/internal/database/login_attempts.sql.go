// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: login_attempts.sql

package database

import (
	"context"
	"database/sql"
)

const deleteOldLoginAttempts = `-- name: DeleteOldLoginAttempts :exec
DELETE FROM login_attempts
WHERE last_attempt < NOW() - make_interval(days => $1)
AND (locked_until IS NULL OR locked_until < NOW())
`

func (q *Queries) DeleteOldLoginAttempts(ctx context.Context, days int32) error {
	_, err := q.db.ExecContext(ctx, deleteOldLoginAttempts, days)
	return err
}

const getLoginAttempts = `-- name: GetLoginAttempts :one
SELECT id, username, failed_count, locked_until, last_attempt FROM login_attempts
WHERE username = $1
`

func (q *Queries) GetLoginAttempts(ctx context.Context, username string) (LoginAttempt, error) {
	row := q.db.QueryRowContext(ctx, getLoginAttempts, username)
	var i LoginAttempt
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.FailedCount,
		&i.LockedUntil,
		&i.LastAttempt,
	)
	return i, err
}

const lockAccount = `-- name: LockAccount :exec
UPDATE login_attempts
SET locked_until = $2, last_attempt = NOW()
WHERE username = $1
`

type LockAccountParams struct {
	Username    string
	LockedUntil sql.NullTime
}

func (q *Queries) LockAccount(ctx context.Context, arg LockAccountParams) error {
	_, err := q.db.ExecContext(ctx, lockAccount, arg.Username, arg.LockedUntil)
	return err
}

const resetLoginAttempts = `-- name: ResetLoginAttempts :exec
UPDATE login_attempts
SET failed_count = 0, locked_until = NULL, last_attempt = NOW()
WHERE username = $1
`

func (q *Queries) ResetLoginAttempts(ctx context.Context, username string) error {
	_, err := q.db.ExecContext(ctx, resetLoginAttempts, username)
	return err
}

const upsertLoginAttempt = `-- name: UpsertLoginAttempt :one
INSERT INTO login_attempts (username, failed_count, locked_until, last_attempt)
VALUES ($1, 1, NULL, NOW())
ON CONFLICT (username)
DO UPDATE SET
  failed_count = login_attempts.failed_count + 1,
  last_attempt = NOW()
RETURNING id, username, failed_count, locked_until, last_attempt
`

func (q *Queries) UpsertLoginAttempt(ctx context.Context, username string) (LoginAttempt, error) {
	row := q.db.QueryRowContext(ctx, upsertLoginAttempt, username)
	var i LoginAttempt
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.FailedCount,
		&i.LockedUntil,
		&i.LastAttempt,
	)
	return i, err
}
