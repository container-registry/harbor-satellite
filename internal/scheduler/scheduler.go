package scheduler

import (
	"context"
	"fmt"
	"sync"

	"github.com/robfig/cron/v3"
	"github.com/rs/zerolog"
)

type SchedulerKey string

const BasicSchedulerKey SchedulerKey = "basic-scheduler"
const StopProcessEventName string = "stop-process-event"
const StopAllProcessesEventName string = "stop-all-processes-event"

type StopProcessEventPayload struct {
	Id          cron.EntryID
	ProcessName string
}

type StopAllProcessesPayload struct {
	Message string
}

type Scheduler interface {
	// GetSchedulerKey would return the key of the scheduler which is unique and for a particular scheduler
	// and is used to get the scheduler from the context
	GetSchedulerKey() SchedulerKey
	// Schedule would add a process to the scheduler
	Schedule(process Process) error
	// Start would start the scheduler
	Start() error
	// Stop would stop the scheduler
	Stop() error
	// Listen for events from the processes
	ListenForProcessEvent()
}

type BasicScheduler struct {
	// name is the key of the scheduler
	name SchedulerKey
	// cron is the cron scheduler
	cron *cron.Cron
	// processes is a map of processes which are attached to the scheduler
	processes map[string]Process
	// locks is a map of locks for each process which is used to schedule if the process are interdependent
	locks map[string]*sync.Mutex
	// stopped is a flag to check if the scheduler is stopped
	stopped bool
	// counter is the counter for the unique ID of the process
	counter uint64
	// mu is the mutex for the scheduler
	mu sync.Mutex
	// ctx is the context of the scheduler
	ctx context.Context
	// EventBroker is the event broker which would be used to emit and listen to the events
	EventBroker *EventBroker
	// Logger for the basic scheduler
	logger *zerolog.Logger
}

func NewBasicScheduler(ctx context.Context, logger *zerolog.Logger) Scheduler {
	scheduler := &BasicScheduler{
		cron:        cron.New(),
		processes:   make(map[string]Process),
		locks:       make(map[string]*sync.Mutex),
		mu:          sync.Mutex{},
		name:        BasicSchedulerKey,
		ctx:         ctx,
		logger:      logger,
		EventBroker: NewEventBroker(),
	}
	return scheduler
}

func (s *BasicScheduler) GetSchedulerKey() SchedulerKey {
	return s.name
}

func (s *BasicScheduler) Schedule(process Process) error {
	s.logger.Info().Msgf("Scheduling process %s", process.GetName())
	s.mu.Lock()
	defer s.mu.Unlock()
	if _, exists := s.processes[process.GetName()]; exists {
		return fmt.Errorf("process %s already exists", process.GetName())
	}
	// Add the global event broker to the process
	process.AddEventBroker(s.EventBroker, s.ctx)
	// Add the process to the scheduler
	cronEntryId, err := s.cron.AddFunc(process.GetCronExpr(), func() {
		err := s.executeProcess(process)
		if err != nil {
			s.logger.Error().Err(err).Msgf("Error executing process %s", process.GetName())
		}
	})
	if err != nil {
		return fmt.Errorf("error adding process to scheduler: %w", err)
	}
	s.processes[process.GetName()] = process
	s.logger.Info().Msgf("Process %s scheduled with cron expression %s", process.GetName(), process.GetCronExpr())
	process.SetID(cronEntryId)
	return nil
}

func (s *BasicScheduler) Start() error {
	s.logger.Debug().Msg("Starting up scheduler for cron jobs")
	s.cron.Start()
	return nil
}

func (s *BasicScheduler) Stop() error {
	s.mu.Lock()
	defer s.mu.Unlock()
	s.stopped = true
	s.EventBroker.Close()
	s.cron.Stop()
	return nil
}

func (s *BasicScheduler) executeProcess(process Process) error {
	if s.stopped {
		return fmt.Errorf("scheduler is stopped")
	}
	// Execute the process
	return process.Execute(s.ctx)
}

func (s *BasicScheduler) ListenForProcessEvent() {
	s.logger.Debug().Msg("Scheduler is listening for events generated by the processes ...")
	for {
		select {
		case event := <-s.EventBroker.Subscribe(StopProcessEventName):
			s.logger.Info().Msgf("Event received: %v", StopProcessEventName)
			payload := event.Payload.(StopProcessEventPayload)
			s.logger.Info().Msgf("Stopping process %s, with cron id %d", payload.ProcessName, payload.Id)
			s.StopProcess(payload.Id)
		case event := <-s.EventBroker.Subscribe(StopAllProcessesEventName):
			payload := event.Payload.(StopAllProcessesPayload)
			s.logger.Warn().Msgf("Cancelling all processes: %s", payload.Message)
			s.EventBroker.Close()
		case <-s.ctx.Done():
			s.EventBroker.Close()
			s.logger.Info().Msg("Scheduler is stopping listening for events ...")
			return
		}
	}
}

func (s *BasicScheduler) StopProcess(id cron.EntryID) {
	s.cron.Remove(id)
}
